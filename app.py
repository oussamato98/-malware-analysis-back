import imaplib
import os

from flask import Flask, request, jsonify
from email.parser import BytesParser
from email.policy import default
import json
import time
import requests
import simple_colors
import nacl.secret
import nacl.utils
from flask_cors import CORS

import base64


# Connect to the email server
def connect_mail(login, password):
    mail = imaplib.IMAP4_SSL('imap.gmail.com')
    mail.login(login, password)
    mail.select('inbox')
    return mail


# Your VirusTotal API key
vt_api_key = "313dfd2f502ee4d65afd004b740cc0ecfb5e8436f38f3bbe54655b87e29be5d6"

headers = {
    "x-apikey": vt_api_key
}


def scan_with_virustotal_v3(file_data, filename):
    url = "https://www.virustotal.com/api/v3/files"
    files = {'file': (filename, file_data)}
    response = requests.post(url, headers=headers, files=files)
    result = response.json()

    # Check if the upload was successful
    if response.status_code == 200:
        # API v3 uses 'id' instead of 'resource'
        file_id = result['data']['id']
        print(f"File {filename} uploaded to VirusTotal, file ID: {file_id}")
        return file_id
    else:
        print(f"Failed to upload {filename} to VirusTotal.")
        return None


def get_virustotal_report_v3(file_id):
    url = f"https://www.virustotal.com/api/v3/analyses/{file_id}"
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        report = response.json()
        return report
    else:
        print(f"Failed to get the report for file ID {file_id}")
        return None

def write_report_to_file(report, filename="report.json"):
    with open(filename, 'w') as report_file:  # 'w' mode to overwrite the file
        json.dump(report, report_file, indent=4)


def full_scan(login, password):

    open('report.json', 'w').close()

    # Search for all emails
    mail = connect_mail(login, password)
    type, data = mail.search(None, 'ALL')

    emails = []  # List to store email dictionaries

    for num in data[0].split():
        typ, data = mail.fetch(num, '(RFC822)')
        raw_email = data[0][1]
        parser = BytesParser(policy=default)
        parsed_email = parser.parsebytes(raw_email)

        # Initialize dictionary to hold email parts
        email_details = {
            'From': parsed_email['from'],
            'Subject': parsed_email['subject'],
            'Body': None,
            'Attachments': []
        }

        # Check if the email is multipart
        if parsed_email.is_multipart():
            for part in parsed_email.iter_parts():
                # Get the content type
                content_type = part.get_content_type()
                content_disposition = part.get_content_disposition()
                # If part is text (plain or HTML)
                if content_type in ('text/plain', 'text/html') and content_disposition != 'attachment':
                    email_details['Body'] = part.get_content()
                    # If part is an attachment
                elif content_disposition == 'attachment':
                    filename = part.get_filename()
                    payload = part.get_payload(decode=True)
                    encoded_payload = base64.b64encode(payload)  # Encode the attachment
                    attachment = {
                        'Filename': filename,
                        'Data': encoded_payload.decode()  # Convert bytes to string for JSON serialization
                    }
                    email_details['Attachments'].append(attachment)
                    # Scan the attachment with VirusTotal v3
                    file_id = scan_with_virustotal_v3(encoded_payload, filename)
                    # Wait a bit for the scan to complete. You might need to adjust this.
                    print("Waiting for VirusTotal to process the file...")
                    time.sleep(60)  # Wait for 15 seconds initially.
                    # Get the report for the uploaded file (you might need to poll for this)
                    report = get_virustotal_report_v3(file_id)
                    if report:
                        write_report_to_file(report)

        else:
            # Email is not multipart
            payload = parsed_email.get_payload(decode=True)
            email_details['Body'] = payload.decode()
        emails.append(email_details)

    mail.close()
    mail.logout()

    # Convert the list of email details to JSON
    json_data = json.dumps(emails, indent=4)

    # Write the JSON data to a file
    with open('emails.json', 'w') as jsonfile:
        jsonfile.write(json_data)

    print("Emails have been written to emails.json")
    print("The scan report have been written to report.json\n")

    report_file_path = 'report.json'
    with open(report_file_path, 'r') as report_file:
        content = report_file.read()
        content = content[:-3]
    with open(report_file_path, 'w') as report_file:
        report_file.write("[" + content + "}}]")
    malicious_detections = 0
    message = ''
    try:
        with open(report_file_path, 'r') as report_file:
            reports = json.load(report_file)
            for report in reports:
                stats = report.get("data", {}).get("attributes", {}).get("stats", {})
                malicious_detections += stats.get("malicious", 0)
        if malicious_detections > 0:
            print(simple_colors.red(
                f"There were {malicious_detections} malicious detections found in the report."))
            message += f"There were {malicious_detections} malicious detections found in the report."

        else:
            print(simple_colors.green("No malicious detections were found. You're Safe !"))
            message = message + "No malicious detections were found. You're Safe !"
    except FileNotFoundError:
        print(f"The file {report_file_path} does not exist.")
        message = message + "The file {report_file_path} does not exist."
    except json.JSONDecodeError:
        print(f"There was an error decoding the JSON data from {report_file_path}.")
        message = message + "There was an error decoding the JSON data from {report_file_path}."
    except AttributeError as e:
        print(f"An error occurred: {e}")
        message = message + "There was an error decoding the JSON data from {report_file_path}."
    return message


app = Flask(__name__)
CORS(app, supports_credentials=True)
# La clé secrète statique doit correspondre exactement à celle utilisée dans le frontend
SECRET_KEY_BYTES = bytes(
    [146, 150, 173, 53, 220, 33, 68, 209, 15, 38, 151, 207, 104, 76, 7, 11, 99, 142, 19, 193, 158, 106, 215, 248, 34,
     133, 14, 196, 46, 98, 155, 165])


def decrypt_message(encrypted_message_base64, nonce_base64, key):
    box = nacl.secret.SecretBox(key)
    nonce = base64.b64decode(nonce_base64)
    encrypted_message = base64.b64decode(encrypted_message_base64)
    decrypted = box.decrypt(encrypted_message, nonce)
    return decrypted.decode('utf-8')


@app.route('/login', methods=['POST'])
def login():
    data = request.json
    email = data['email']
    encrypted_password = data['password']['encrypted']
    nonce = data['password']['nonce']

    # Décryptez le mot de passe en utilisant la clé secrète et le nonce
    decrypted_password = decrypt_message(encrypted_password, nonce, SECRET_KEY_BYTES)

    # Affichez l'email et le mot de passe décrypté
    print('Email:', email)
    print('Decrypted password:', decrypted_password)

    message = full_scan(email, decrypted_password)

    return jsonify(message)


@app.route('/get_report', methods=['GET'])
def get_report():
    try:
        with open('report.json', 'r') as report_file:
            report_content = json.load(report_file)
        # Assurez-vous que le contenu est une liste pour éviter les problèmes de formatage
        if not isinstance(report_content, list):
            report_content = [report_content]
        return jsonify(report_content)
    except FileNotFoundError:
        return jsonify({"error": "Report file not found."}), 404
    except json.JSONDecodeError:
        return jsonify({"error": "Error decoding the report file."}), 500



if __name__ == '__main__':
    app.run(debug=True)
